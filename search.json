[{"title":"Redis集群","path":"/Redis-cluster/","content":"Redis版本：6.0.6系统：Centos 7.8 Redis安装安装编译依赖工具yum install -y gcc gcc-c++ jemalloc centos-release-scl devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils （此命令执行2次） scl enable devtoolset-9 bash 进行编译安装：make PREFIX=/usr/local/redis install 安装好后，redis 主目录为 /usr/local/redis 创建配置目录mkdir -p /usr/local/redis/&#123;data,etc,log&#125; //创建完后的结构 [root@xxx redis-6.0.6]# tree /usr/local/redis/ /usr/local/redis/ ├── bin │ ├── redis-benchmark │ ├── redis-check-aof │ ├── redis-check-rdb │ ├── redis-cli │ ├── redis-sentinel -&gt; redis-server │ └── redis-server ├── data ├── etc └── log 根据实际情况创建配置文件举例创建3主3从，单台服务器不同端口去创建（如不同服务器则修改对应ip 即可）。 端口从 6379 ~ 6384 配置文件位置 /usr/local/redis/etc/63xx/redis.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576protected-mode noport 6379tcp-backlog 511timeout 0tcp-keepalive 300daemonize yessupervised nopidfile /usr/local/redis/etc/6379.pidloglevel noticelogfile /usr/local/redis/log/6379.logdatabases 16always-show-logo yessave 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump-6379.rdbrdb-del-sync-files nodir /usr/local/redis/data/masterauth ThisisPass99!replica-serve-stale-data yesreplica-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-diskless-load disabledrepl-disable-tcp-nodelay noreplica-priority 100acllog-max-len 128requirepass ThisisPass99!maxmemory 2gbmaxmemory-policy volatile-lrulazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush nolazyfree-lazy-user-del noappendonly yesappendfilename &quot;appendonly-6379.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yesaof-use-rdb-preamble yeslua-time-limit 5000cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 5000cluster-announce-ip 172.25.62.195cluster-announce-port 6379cluster-announce-bus-port 16379slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000stream-node-max-bytes 4096stream-node-max-entries 100activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit replica 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 50dynamic-hz yesaof-rewrite-incremental-fsync yesrdb-save-incremental-fsync yesjemalloc-bg-thread yes 启动各个节点1/usr/local/redis/bin/redis-server /usr/local/redis/etc/63xx/redis.conf 各个节点启动后： 1234567[root@xxx redis]# ps -ef|grep redisroot 14459 1 0 18:38 ? 00:00:00 ./bin/redis-server *:6379 [cluster]root 14470 1 0 18:38 ? 00:00:00 ./bin/redis-server *:6380 [cluster]root 14476 1 0 18:38 ? 00:00:00 ./bin/redis-server *:6381 [cluster]root 14482 1 0 18:38 ? 00:00:00 ./bin/redis-server *:6382 [cluster]root 14489 1 0 18:38 ? 00:00:00 ./bin/redis-server *:6383 [cluster]root 14495 1 0 18:38 ? 00:00:00 ./bin/redis-server *:6384 [cluster] 创建集群./bin/redis-cli --cluster create --cluster-replicas 1 0.0.0.0:6379 0.0.0.0:6380 0.0.0.0:6381 0.0.0.0:6382 0.0.0.0:6383 0.0.0.0:6384 -a ThisisPass99! 输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@xxx redis]# ./bin/redis-cli --cluster create --cluster-replicas 1 0.0.0.0:6379 0.0.0.0:6380 0.0.0.0:6381 0.0.0.0:6382 0.0.0.0:6383 0.0.0.0:6384 -a ThisisPass99!Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 0.0.0.0:6383 to 0.0.0.0:6379Adding replica 0.0.0.0:6384 to 0.0.0.0:6380Adding replica 0.0.0.0:6382 to 0.0.0.0:6381&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity[WARNING] Some slaves are in the same host as their masterM: 6a7c5727cad6adbf72ab48cb916c41b7af3ae457 0.0.0.0:6379 slots:[0-5460] (5461 slots) masterM: 6078150eb72c898296d719756c4f713e0dfd445c 0.0.0.0:6380 slots:[5461-10922] (5462 slots) masterM: 7864aef8fbe43c9f29040905780d610be9c3cc08 0.0.0.0:6381 slots:[10923-16383] (5461 slots) masterS: 9929b770b836881e78c06b128c64461b89c3063f 0.0.0.0:6382 replicates 6a7c5727cad6adbf72ab48cb916c41b7af3ae457S: 41f352f038a8a109e2696e12491cd793cd5feef2 0.0.0.0:6383 replicates 6078150eb72c898296d719756c4f713e0dfd445cS: 01cc17f43586df37011540ece2c01512f4126c8f 0.0.0.0:6384 replicates 7864aef8fbe43c9f29040905780d610be9c3cc08Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join&gt;&gt;&gt; Performing Cluster Check (using node 0.0.0.0:6379)M: 6a7c5727cad6adbf72ab48cb916c41b7af3ae457 0.0.0.0:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)M: 7864aef8fbe43c9f29040905780d610be9c3cc08 172.25.62.195:6381 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: 6078150eb72c898296d719756c4f713e0dfd445c 172.25.62.195:6380 slots:[5461-10922] (5462 slots) master 1 additional replica(s)S: 41f352f038a8a109e2696e12491cd793cd5feef2 172.25.62.195:6383 slots: (0 slots) slave replicates 6078150eb72c898296d719756c4f713e0dfd445cS: 01cc17f43586df37011540ece2c01512f4126c8f 172.25.62.195:6384 slots: (0 slots) slave replicates 7864aef8fbe43c9f29040905780d610be9c3cc08S: 9929b770b836881e78c06b128c64461b89c3063f 172.25.62.195:6382 slots: (0 slots) slave replicates 6a7c5727cad6adbf72ab48cb916c41b7af3ae457[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 集群检查连接任意节点 ./bin/redis-cli -c -p 6379 授权 auth ThisisPass99! cluster相关命令12345678910111213141516171819CLUSTER INFO 127.0.0.1:6379&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:519cluster_stats_messages_pong_sent:535cluster_stats_messages_sent:1054cluster_stats_messages_ping_received:530cluster_stats_messages_pong_received:519cluster_stats_messages_meet_received:5cluster_stats_messages_received:1054 项目Spring Boot 集成redis1. 手动调用a）增加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; b）增加配置123456789101112131415161718192021spring: application: name: redis-demo redis: # 集群模式默认就是0库 database: 0 password: ThisisPass99! timeout: 10000 cluster: nodes: 172.25.62.195:6379,172.25.62.195:6380,172.25.62.195:6381,172.25.62.195:6382,172.25.62.195:6383,172.25.62.195:6384 max-redirects: 3 jedis: pool: #连接池最大连接数（使用负值表示没有限制 max-active: 600 #连接池最大阻塞等待时间（使用负值表示没有限制 max-wait: 2000 #连接池中的最大空闲连接 max-idle: 600 #连接池中的最小空闲连接 min-idle: 10 c) 调用redisTemplate方法123456789101112131415161718192021@RestController@RequestMapping(&quot;/redis&quot;)public class RedisController &#123; @Autowired private RedisTemplate redisTemplate; @ResponseBody @RequestMapping(&quot;/set&quot;) public String set(@RequestParam(required = false) String key, @RequestParam(required = false) String value) &#123; redisTemplate.opsForValue().set(key, value); return &quot;ok&quot;; &#125; @ResponseBody @RequestMapping(&quot;/get&quot;) public String get(@RequestParam(required = false) String key) &#123; return (String)redisTemplate.opsForValue().get(key); &#125;&#125; 2. 作为缓存使用直接作为缓存使用，有注解的方法，可以很好的对代码无入侵，配置好后基本无感知。 a)额外增加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; b)增加配置类123456789101112131415161718192021@Configuration@EnableAutoConfigurationpublic class RedisCacheConfig extends CachingConfigurerSupport &#123; @Autowired private JedisConnectionFactory jedisConnectionFactory; //若干方法省略 ... @Bean public CacheManager cacheManager() &#123; RedisCacheManager cacheManager = new RedisCacheManager( RedisCacheWriter.nonLockingRedisCacheWriter(jedisConnectionFactory), this.getRedisCacheConfigurationWithTtl(60 * 60 * 3), // 默认策略，未配置的 key 会使用这个 this.getRedisCacheConfigurationMap() // 指定 key 策略 ); return cacheManager; &#125; &#125; c)需要缓存的地方增加缓存注解 @Cacheable123456789101112131415161718192021@Servicepublic class StudentServiceImpl implements StudentService &#123; @Override @Cacheable(cacheNames = &quot;student&quot;, key = &quot;#p0&quot;) public Student findByName(String name) &#123; //模拟查找 Student student = new Student(); student.setName(name); student.setAge(new Random().nextInt(40)); return student; &#125; @Override @Cacheable(cacheNames = &quot;student&quot;, key = &quot;#p0&quot;) public Student findByName2(String name) &#123; //模拟查找 Student student = new Student(); student.setName(name); student.setAge(new Random().nextInt(40)); return student; &#125;&#125; 附 - 相关代码及配置文件redis 下载链接相关代码及配置文件Github地址","tags":["redis"],"categories":["技术"]},{"title":"Centos SCL源","path":"/Centos-scl/","content":"Centos用yum安装scl下报错，备忘一下更换源。 yum -y update Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile Could not retrieve mirrorlist http://mirrorlist.centos.org?arch=x86_64&amp;release=7&amp;repo=sclo-rh error was 14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; Unknown error&quot; 原因CentOS7的SCL源在2024年6月30日停止维护了。 当scl源里面默认使用了centos官方的地址，无法连接，需要替换为其它源。 替换为阿里的源重命名原来的文件：目录 /etc/yum.repos.d mv CentOS-SCLo-scl.repo CentOS-SCLo-scl.repo-bak mv CentOS-SCLo-scl-rh.repo CentOS-SCLo-scl-rh.repo-bak 创建新的源文件vim CentOS-SCLo-scl-rh.repo 写入[centos-sclo-rh] name=CentOS-7 - SCLo rh baseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/rh/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-SCLo 改用新的源yum -y update","tags":["centos"],"categories":["centos"]},{"title":"Java的注解","path":"/Java-annotation/","content":"Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 注解的定义注解（Annotation）是Java语言中一种特殊的修饰符，它可以用于类、方法、参数、变量、构造器以及包声明中，用于为Java代码提供元数据。相对于其他修饰符如public、final等，注解并不直接影响代码的语义，但却能被某些工具软件（如编译器、框架）所读取和利用。 注解的作用 编译检查 - 如@Override放在方法前，如果该方法不是重写父类的方法，则编译器会发出警告。 代码分析 - 通过代码里标识的注解，程序可以在编译时进行一些基于注解的处理。注解信息和JAVA的反射功能在一起时会使得程序的功能更加强大。 编译时动态处理 - 如常见的Java框架Spring、Hibernate、JUnit等，会在编译时读取注解的信息，然后根据注解的信息进行一些其他处理。 生成额外的文件 - 如Javadoc工具会根据源码中的注解来生成API文档。 内置注解Java提供了一些预定义的注解，如： @Override: 限定重写父类方法。 @Deprecated: 表示某个程序元素（如方法）已经过时。 @SuppressWarnings: 告诉编译器忽略指定的警告。 @SafeVarargs: 抑制堆污染警告。 @FunctionalInterface: 标记一个接口为函数式接口。 元注解：用于注解其他注解的注解称为元注解，简单理解就是用于注解其它新定义的注解。Java提供了以下几种元注解： @Target: 表明该注解可以被应用于什么地方（如方法、类、字段等）。 @Retention: 表明该注解的生命周期（仅源代码、编译期、运行期）。 @Documented: 表示使用该注解的元素应被Javadoc或其他工具文档化。 @Inherited: 表示该注解可以被子类继承 注解分类 由编译器使用的注解 含义：这类注解不会被编译进入 .class 文件，在编译后它们就被编译器丢弃了。 示例： @Override：此注解让编译器检查该方法是否正确地实现了覆写。 @SuppressWarnings：此注解告诉编译器忽略此处代码产生的警告。 由工具处理 .class 文件使用的注解 含义：有些工具在加载 class 的时候，会对 class 文件做动态修改，以实现一些特殊的功能。这类注解会被编译进入 .class 文件，但在加载完成后并不会存在于内存中。这类注解主要被一些底层库使用，一般我们不需要自己处理。 示例：可以参考 lombok。 在程序运行期能够读取的注解 含义：这些注解在加载后会一直存在于 JVM 中，是最常用的注解。 示例：配置了 @PostConstruct 的方法会在调用构造方法后自动被调用。这是 Java 代码通过读取该注解实现的功能，JVM 本身并不会识别该注解。 注解的基本语法注解的声明类似于接口的声明，但是前面多了一个@符号： 1234//定义注解public @interface MyAnnotation &#123; String value() default &quot;&quot;; //定义value属性&#125; 12345//使用注解@MyAnnotation(value=&quot;This is my custom annotation&quot;)public class MyClass &#123; // class body&#125; 注解的实现原理与底层机制在Java中，注解的实现基于反射。注解本身被编译器处理为接口，其方法则对应注解的属性。当代码运行时，可以通过反射访问这些注解和它们的属性。 注解的属性值在编译时被嵌入到使用注解的类的字节码中。当运行时环境加载这个类时，注解数据成为类的一部分，可以通过Java反射API来查询。 注解的提取结合注解和反射可以实现强大的动态处理能力。你可以在运行时查询一个类、方法或字段上的注解信息，并据此做出相应的处理。这在很多框架中被广泛应用，比如Spring和Hibernate。 例如，下面的代码演示了如何使用反射来读取方法上的注解： 123456789public class AnnotationProcessor &#123; public void process(Object obj) throws Exception &#123; for (Method m : obj.getClass().getDeclaredMethods()) &#123; if (m.isAnnotationPresent(MyAnnotation.class)) &#123; // 处理带有@MyAnnotation的方法 &#125; &#125; &#125;&#125; 注解实际用例注解实际使用是更加简化编码，更方便，简洁去维护一类代码。如以下使用都可以有替方法，但是用了注解后，代码看起来更加简洁，代码的耦合度也更加小。 lombok 编译时处理构造方法、set&#x2F;get 方法等12345678import lombok.Data;//增加lombok的@data注解，就不需要额外写set、get方法@Datapublic class Student &#123; private String name; private Integer age;&#125; @autowire&#x2F;@resource spring中注入对应的service 123//controller中注入对应的service@Autowiredprivate StudentService studentService; 数据库读写分离 @Write @read 方便 数据缓存，如Redis 缓存 Spring web 中 @RestController @ResponseBody 自定义注解的使用自定义一个注解，作用于service方法，用于打印出不同的方法耗时并在控制台输出。 所有demo见 Github 1. 定义注解123public @interface CustomLog &#123;&#125; 2. 在对应service中使用12345678910111213141516171819202122232425262728293031import com.technotes.annotationdemo.annotation.CustomLog;import com.technotes.annotationdemo.model.Student;import com.technotes.annotationdemo.service.StudentService;import org.springframework.stereotype.Service;import java.util.Random;@Servicepublic class StudentServiceImpl implements StudentService &#123; @Override //增加刚刚写的 CustomLog @CustomLog public Student findByName(String name) &#123; //模拟查找 Student student = new Student(); student.setName(name); student.setAge(new Random().nextInt(40)); return student; &#125; @Override //增加刚刚写的 CustomLog @CustomLog public Student findByName2(String name) &#123; //模拟查找 Student student = new Student(); student.setName(name); student.setAge(new Random().nextInt(40)); return student; &#125;&#125; 3.在不同方法中进行调用12345678910111213141516171819@RestController@RequestMapping(&quot;/student&quot;)public class StudentController &#123; @Autowired private StudentService studentService; @ResponseBody @RequestMapping(&quot;/find&quot;) public Student findByName(@RequestParam(required = false) String name) &#123; return studentService.findByName(name); &#125; @ResponseBody @RequestMapping(&quot;/find2&quot;) public Student findByName2(@RequestParam(required = false) String name) &#123; return studentService.findByName2(name); &#125;&#125; 4.访问查看结果1234访问:http://localhost:8080/student/find?name=123输出:com.technotes.annotationdemo.service.impl.StudentServiceImpl findByName Time 3 ms 1234访问:http://localhost:8080/student/find2?name=123输出:com.technotes.annotationdemo.service.impl.StudentServiceImpl findByName2 Time 1 ms","tags":["java"],"categories":["技术"]},{"title":"Java的反射","path":"/java-reflection/","content":"反射被视为动态语言的关键。Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。 反射的定义在Java中反射(Reflection)是一种Java 程序运行期间的动态技术，它可以在运行时(runtime)检査、修改其自身结构或行为。通过反射，程序可以访问、检测和修改它自己的类、对象、方法、属性等成员。即在运行状态中，对于任意一个类，都能够知道这个类的所以属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 反射的作用 动态加载类:程序可以在运行时动态地加载类库中的类； 动态创建对象:反射可以基于类的信息，程序可以在运行时，动态创建对象实例; 调用方法:反射可以根据方法名称，程序可以在运行时，动态地调用对象的方法(即使方法在编写程序时还没有定义) 访问成员变量:反射可以根据成员变量名称，程序可以在运行时，访问和修改成员变量(反射可以访问私有成员变量) 运行时类型信息:反射允许程序在运行时，查询对象的类型信息，这对于编写通用的代码和库非常有用; 实现反射机制的类Java中主要由以下的类来实现Java反射机制（这些类都位于java.lang.reflect包中）： Class类：代表一个类。 Field类：代表类的成员变量（成员变量也称为类的属性）。 Method类：代表类的方法。 Constructor类：代表类的构造方法。 Array类：提供了动态创建数组，以及访问数组的元素的静态方法。 反射的基础使用获取Class对象反射的第一步是获取 Class 对象(动态加载类)。Class 对象表示某个类的元数据，可以通过以下几种方式获取： 12345678//方式1:通过类名Class stringClass1 = String.class;//方式2：通过Class类的forName()方法Class stringClass2 = Class.forName(&quot;java.lang.String&quot;); //方式3：通过对象调用getClass()方法Class stringClass3 = &quot;&quot;.getClass(); 解析字符串为Java对象使用fastjson的JSON类解析一个字符串为Java对象，并输出该对象的字段值。 1234567891011121314151617import com.alibaba.fastjson.JSON;import lombok.Data;public class ReflectionTest &#123; public static void main(String[] args) &#123; String demoStr = &quot;&#123;\\&quot;age\\&quot;:18,\\&quot;name\\&quot;:\\&quot;demo1\\&quot;&#125;&quot;; Demo demo = JSON.parseObject(demoStr, Demo.class); System.out.printf(&quot;name is : %s%n&quot;, demo.getName()); System.out.printf(&quot;age is : %s%n&quot;, demo.getAge()); &#125;&#125;@Dataclass Demo &#123; private String name; private Integer age;&#125; 输出 12name is : demo1age is : 18 获取类的相关信息通过 Class 对象在运行时获取一个类的相关信息，包括类名、包名、成员变量（字段）、成员方法等。 123456789101112131415161718192021222324252627282930import java.lang.reflect.*;public class ReflectionTest2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class clz = Class.forName(&quot;java.util.HashMap&quot;); //获取类名 System.out.println(&quot;完全限定名：&quot; + clz.getName()); System.out.println(&quot;简单的类名：&quot; + clz.getSimpleName()); //获取包名 System.out.println(&quot;package&quot; + clz.getPackage().getName()); System.out.println(); //获取成员变量 Field[] fieldArray = clz.getDeclaredFields(); System.out.println(&quot;成员变量(字段)&quot;); for (Field field : fieldArray) &#123; System.out.println(field); &#125; System.out.println(); //获取成员方法 Method[] methodArray = clz.getDeclaredMethods(); System.out.println(&quot;成员方法&quot;); for (Method method : methodArray) &#123; System.out.println(method); &#125; &#125;&#125; 通过反射创建对象通过反身创建对象，通过反射获取方法，通过反射执行方法等。 1234567891011121314151617181920212223242526import lombok.SneakyThrows;import java.lang.reflect.Method;public class ReflectionTest3 &#123; @SneakyThrows public static void main(String[] args) &#123; //获取class对象 Class&lt;Demo&gt; clazz = Demo.class; //获取Demo class 的setName 方法 Method setName = clazz.getMethod(&quot;setName&quot;, String.class); //获取Demo class 的实例 Demo demo = clazz.newInstance(); //在实例化后的对象demo执行setName方法 setName.invoke(demo, &quot;new Name&quot;); //获取name并输出 System.out.printf(&quot;demo name is : %s%n&quot;, demo.getName()); //通过反射在demo对象执行getName Method getName = clazz.getMethod(&quot;getName&quot;); System.out.printf(&quot;demo reflect getname is : %s%n&quot;, getName.invoke(demo)); //通过反射在其它demo对象上执行getName Demo demo2 = new Demo(); demo2.setName(&quot;demo2&quot;); System.out.printf(&quot;demo2 reflect getname is : %s%n&quot;, getName.invoke(demo2)); &#125;&#125; 输出 123demo name is : new Namedemo reflect getname is : new Namedemo2 reflect getname is : demo2 反射的性能问题反射虽然功能强大，但由于是在运行时动态操作类，因此性能相对较低。此外，反射也会破坏封装性，使用时要谨慎。 反射的安全性使用反射时需要注意安全问题，因为它可以绕过Java的访问控制机制。例如，可以访问私有字段或方法，因此在开发中使用反射要特别小心。甚至在运行时，添加、改变方法。 反射的常见场景 框架开发：如 Spring 中的依赖注入、Hibernate 中的 ORM 等。 调试工具：如 Java 的调试器、分析工具等。 动态代理：在 Java 中，动态代理依赖于反射。 常用的fastjson JSONObject.parseObject(xxStr)","tags":["java"],"categories":["技术"]},{"title":"Java的学习","path":"/java-hello-world/","content":"Java并不算是一个好学的语言，感觉主要原因是： 1. 思维的转变，比如面向对象； 2. 配置复杂，虽然现在一些配置尽可能简单，对于初学者还是没有达到开箱即用的地步； 3. 及时反馈，这点相对于一些前端语言，可以及时的看到效果； 4. 扩展性强，导致要了解学习的内容过多。 面向对象Java和其它语言很大一个不同就是面向对象。理解类和对象基本就行了，比如人是一个类，具体张三是人这个类的对象，李四是人这类的另一个对象；动物是一个类，猫是动物的一个对象，狗是动物的另一个对象。 张三具有行走的方法，猫也具有行走的方法。 简单理解面向过程和面向对象的方式就是： 面向过程就是从第一行依次执行到最后一行； 面向对象是把现实问题抽象出来，把某一类定义为一个类，类具有它自己的方法。 设计模式很多语言都会有一些设计模式，或者说语言在设计的时候本来就有很多设计的模式在里面，只是感觉Java把这些凸显的更加明显。想要理解一些代码，掌握编程的思想，设计的模式是必不可少的。比如 单例模式、工厂模式、接口适配器模式、策略模式 等等。 这些模式没必要完全记住其概念，但是一定要熟悉了解，主要还是在于思维的转变，从平常日常生活思考问题的思维转变成编程思维。其实有时候很多设计模式在用，自己却浑然不知。 Java基础Java基础主要 基本语法、基本数据结构、类、对象、接口、继承、多态 等。然后就是一些框架的学习运用，解决问题的思路和方法。 Java进阶进阶一些内容有多线程、并发编程、反射、泛型、注解、web开发、Spring及Spring Boot等。 Java高级进阶一些内容有分布式、高并发处理、相关中间件学习（消息队列、缓存系统、数据库中间件、搜索引擎、RPC框架）、封装、异常处理、日志管理、系统平衡 等等。 Java学习是一个长期持久的过程，每一段时间对于同样的问题都会有不同的见解； 有很多个时候都会那种恍然大悟的感觉；另外一个感觉是完全学不完。","tags":["java"],"categories":["技术"]},{"title":"112334","path":"/112334/","content":"233fkfkfdafdaj","tags":["test"],"categories":["tech"]},{"title":"112334666","path":"/test-tech-1/","content":"233fkfkfdafdaj","tags":["test"],"categories":["tech"]},{"title":"Hello World","path":"/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于","path":"/about/index.html","content":"想着用文字的方式记录一些东西 学习笔记偶尔看到一些新的技术或者正在学习的东西，包括不限于编程技术。 技术整理温帮而知新，更想的是把之前的内容查漏补缺，表达是对所学知识很好的一种更固方法 生活分享可以旅游，可以生活感悟，可以发呆.. 站点信息主要为了方便和便宜，就用hexo 和 github pages 来维护。 基本就一个域名的费用。 搭建配置域名熟悉一点大概2小时。 框架：Hexo主题： Stellar插件： hexo-admin、hexo-deployer-git、hexo-generator-cname服务器：github pages"},{"title":"码农的生活","path":"/life/coder.html","content":"从这里开始","tags":[null,null]},{"title":"生活","path":"/life/index.html","content":"从这里开始"},{"title":"国庆xx旅游(占位)","path":"/life/play1.html","content":"从这里开始"},{"title":"24年10月减肥","path":"/life/run-24-10.html","content":"从这里开始","tags":[null],"categories":[null]},{"title":"24年11月减肥","path":"/life/run-24-11.html","content":"从这里开始","tags":[null],"categories":[null]},{"title":"24年12月减肥","path":"/life/run-24-12.html","content":"从这里开始","tags":[null],"categories":[null]},{"title":"24年9月减肥","path":"/life/run-24-9.html","content":"从这里开始","tags":[null],"categories":[null]},{"title":"思考1","path":"/life/think1.html","content":"从这里开始"},{"title":"码农的生活","path":"/photo/coder.html","content":"从这里开始","tags":[null,null]},{"title":"生活","path":"/photo/index.html","content":"从这里开始"},{"title":"国庆xx旅游(占位)","path":"/photo/play1.html","content":"从这里开始"},{"title":"思考1","path":"/photo/think1.html","content":"从这里开始"},{"title":"开始","path":"/wiki/java/index.html","content":"test"},{"title":"开始2","path":"/wiki/database/examples.html","content":"test"},{"title":"开始1","path":"/wiki/database/index.html","content":"test"},{"title":"开始3","path":"/wiki/database/pages.html","content":"test"},{"title":"开始4","path":"/wiki/database/releases.html","content":"test"},{"title":"开始5","path":"/wiki/database/theme-settings.html","content":"test"}]